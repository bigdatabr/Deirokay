"""
The base statement that all other statements inherit from.
"""
from abc import ABC, abstractmethod
from enum import Enum

from pandas import DataFrame

from .._typing import DeirokayStatement


class Backend(Enum):
    """
    The backend that the statement will be generated for.
    """
    PANDAS = 'pandas'
    DASK = 'dask'


VALID_BACKENDS = list(Backend._value2member_map_.keys())


class BaseStatement(ABC):
    """Base abstract statement class for all Deirokay statements.

    Attributes
    ----------
    options : dict
        Statement parameters provided by user.
    """

    name = 'base_statement'
    """str: Statement name when referred in Validation Documents
    (only valid for Deirokay built-in statements)."""
    expected_parameters = ['type', 'severity', 'location']
    """List[str]: Parameters expected for this statement."""
    supported_backends = ['pandas']
    """List[str]: Backends supported by this statement."""

    def __init__(self, options: dict, backend: Backend = 'pandas') -> None:
        assert backend in self.supported_backends, (
            f'`{backend}` is not supported by `{self.name}` statement.'
        )
        self.backend = backend
        if 'report' in self.__abstractmethods__:
            self.report = getattr(self, f'_report_{backend}', None)
            if not self.report:
                raise ValueError(
                    f'No report function found for `{self.name}` statement.'
                )
            # The class should be informed of this change
            self.__abstractmethods__ -= {'report'}
            self.report.__isabstractmethod__ = False

        self._validate_options(options)
        self.options = options

    def __init_subclass__(cls) -> None:
        """Validate subclassed statement."""
        assert cls.name != BaseStatement.name, (
            'You should specify a `name` attribute for your statement class.'
        )
        invalid_backends = [
            backend for backend in cls.supported_backends
            if backend not in VALID_BACKENDS
        ]
        assert not invalid_backends, (
            f'Invalid backend: {invalid_backends}.'
            f' Valid backends are: {VALID_BACKENDS}'
        )
        assert hasattr(cls, 'report') or all(
            hasattr(cls, f'_report_{backend}')
            for backend in cls.supported_backends
        ), (
            'You should specify a `report` method for your'
            'statement class or a `_report_<backend>` method for each'
            'supported backend.'
        )

    def _validate_options(self, options: dict) -> None:
        """Make sure all provided statement parameters are expected
        by statement classes"""
        cls = type(self)
        unexpected_parameters = [
            option for option in options
            if option not in (cls.expected_parameters +
                              BaseStatement.expected_parameters)
        ]
        if unexpected_parameters:
            raise ValueError(
                f'Invalid parameters passed to {cls.__name__} statement: '
                f'{unexpected_parameters}\n'
                f'The valid parameters are: {cls.expected_parameters}'
            )

    def __call__(self, df: DataFrame) -> dict:
        """Run statement instance."""
        internal_report = self.report(df)
        result = self.result(internal_report)

        final_report = {
            'detail': internal_report,
            'result': result
        }
        return final_report

    @abstractmethod
    def report(self, df: DataFrame) -> dict:
        """Receive a DataFrame containing only columns on the scope of
        validation and returns a report of related metrics that can
        be used later to declare this Statement as fulfilled or
        failed.

        Parameters
        ----------
        df : DataFrame
            The scoped DataFrame columns to be analysed in this report
            by this statement.

        Returns
        -------
        dict
            A dictionary of useful statistics about the target columns.
        """

    @abstractmethod
    def result(self, report: dict) -> bool:
        """Receive the report previously generated and declare this
        statement as either fulfilled (True) or failed (False).

        Parameters
        ----------
        report : dict
            Report generated by `report` method. Should ideally
            contain all statistics necessary to evaluate the statement
            validity.

        Returns
        -------
        bool
            Whether or not this statement passed.
        """

    @staticmethod
    def profile(df: DataFrame) -> DeirokayStatement:
        """Given a template data table, generate a statement dict
        from it.

        Parameters
        ----------
        df : DataFrame
            The DataFrame to be used as template.

        Returns
        -------
        dict
            Statement dict.

        Raises
        ------
        NotImplementedError
            If this method is not implemented by the subclass or the
            profile generation for this statement was intentionally
            skipped.
        """
        raise NotImplementedError
